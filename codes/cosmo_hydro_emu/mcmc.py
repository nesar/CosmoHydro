# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_mcmc.ipynb.

# %% auto 0
__all__ = ['ln_prior', 'ln_like', 'ln_prob', 'chain_init', 'define_sampler', 'do_mcmc', 'mcmc_results', 'log_likelihood0', 'log_likelihood1']

# %% ../nbs/04_mcmc.ipynb 3

import numpy as np
import emcee 
import time
from Flamingo.Clean.hydro_emu.emu import emu_redshift, emulate

def ln_prior(theta, params_list):
    pdf_sum = 0
    for p, param in zip(theta, params_list):
        if not (param[2] < p < param[3]):
            return -np.inf
        p_mu = 0.5 * (param[3] - param[2]) + param[2]
        p_sigma = 1 * (param[3] - p_mu)
        pdf_sum += np.log(1.0 / (np.sqrt(2 * np.pi) * p_sigma)) - 0.5 * (p - p_mu) ** 2 / p_sigma ** 2
    return pdf_sum


def log_likelihood0(theta, x_grid, sepia_model, x, y, yerr):
      
    # new_params = np.append( np.array(theta), [redshift] )[np.newaxis, :]
    # model_grid, model_var_grid = emu_redshift(new_params, sepia_model_list, z_all)
    
    model_grid, model_var_grid = emulate(sepia_model, theta)
    model = np.interp(x, x_grid, model_grid[:, 0])
    model_var = np.interp(x, x_grid, model_var_grid[:, 0, 0])
    
    # sigma2 = yerr**2  + model_var
    sigma2 = yerr**2 # + model_var
    ll = -0.5 * np.sum((y - model)** 2 / sigma2 )
    return ll

def log_likelihood1(theta, x_grid, sepia_model, x, y, yerr):
      
    # new_params = np.append( np.array(theta), [redshift] )[np.newaxis, :]
    # model_grid, model_var_grid = emu_redshift(new_params, sepia_model_list, z_all)
    
    model_grid, model_var_grid = emulate(sepia_model, theta)
    model = np.interp(x, x_grid, model_grid[:, 0])
    model_var = np.interp(x, x_grid, model_var_grid[:, 0, 0])
    
    # sigma2 = yerr**2  + model_var
    sigma2 = yerr**2 # + model_var
    ll = -0.5 * np.sum((y - model)** 2 / sigma2 )
    return ll


def ln_like(theta, x_grid, x_grid1, sepia_model, sepia_model1, x, y, yerr, x1, y1, yerr1):
    
    ll0 = log_likelihood0(theta, x_grid, sepia_model, x, y, yerr)
    ll1 = log_likelihood1(theta, x_grid1, sepia_model1, x1, y1, yerr1)
    
    return ll0 + ll1


def ln_prob(theta, params_list, x_grid, x_grid1, sepia_model, sepia_model1, x, y, yerr, x1, y1, yerr1):
    
    lp = ln_prior(theta, params_list)
    if not np.isfinite(lp):
        return -np.inf
    return lp + ln_like(theta, x_grid, x_grid1, sepia_model, sepia_model1, x, y, yerr, x1, y1, yerr1)


def chain_init(params_list, ndim, nwalkers):
    pos0 = [[param[1] * 1.0 for param in params_list] + 1e-3 * np.random.randn(ndim) for _ in range(nwalkers)]
    return pos0


def define_sampler(ndim, nwalkers, params_list, x_grid, x_grid1, sepia_model, sepia_model1, x, y, yerr, x1, y1, yerr1):
    
    sampler = emcee.EnsembleSampler(nwalkers, ndim, ln_prob, args=(params_list, x_grid, x_grid1, sepia_model, sepia_model1, x, y, yerr, x1, y1, yerr1))
    return sampler


def do_mcmc(sampler, 
            pos, 
            nrun, 
            ndim,
            if_burn=False
            ):

    time0 = time.time()
    pos, prob, state = sampler.run_mcmc(pos, nrun)

    time1 = time.time()
    print('time (minutes):', (time1 - time0)/60. )

    samples = sampler.chain[:, :, :].reshape((-1, ndim))

    if if_burn: 
        print('Burn-in phase')
        sampler.reset()

    else:
        print('Sampling phase')

    return pos, prob, state, samples, sampler


def mcmc_results(samples):
    results = list(map(lambda v: (v[1], v[2] - v[1], v[1] - v[0]), zip(*np.percentile(samples, [16, 50, 84], axis=0))))
    print('mcmc results:', ' '.join(str(result[0]) for result in results))
    return tuple(result[0] for result in results)

