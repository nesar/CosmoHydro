# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_viz.ipynb.

# %% auto 0
__all__ = ['plot_lines_with_param_color', 'plot_scatter_matrix', 'plot_train_diagnostics', 
'sensitivity_plot', 'sensitivity_plot_gsmf', 'validation_plot', 'plot_mcmc', 
'plot_mcmc_combined', 'plot_convergence']

# %% ../nbs/10_viz.ipynb 3
import warnings
warnings.simplefilter("ignore", UserWarning)
import seaborn

import numpy as np
import os
import matplotlib as mpl
import matplotlib.pylab as plt
import pandas as pd
import sepia.SepiaPlot as SepiaPlot
from sepia.SepiaModel import SepiaModel
from sepia.SepiaData import SepiaData
from matplotlib import ticker
from itertools import cycle
import matplotlib.colors as mcolors
import matplotlib.cm as cm
import pygtc
from matplotlib.ticker import FormatStrFormatter


# %% ../nbs/10_viz.ipynb 4
def plot_lines_with_param_color(param_array:np.array=None, # parameter array
                                x_array:np.array=None, # x-axis array
                                y_array_all:np.array=None, # y-axis array
                                title_str:str=None, # Title string
                                xlabel_str:str=None, # x-label string
                                ylabel_str:str=None, # y-label string
                                param_name_str:str=None, # Parameter string,
                                mlim1:np.float32=1e8,
                                mlim2:np.float32=1e13,
                                ax: plt.Axes = None
                               ):
    
    if ax is None:
        f, ax = plt.subplots(1, 1, figsize=(8, 5))
    else:
        f = ax.figure 
    
    

    norm = mpl.colors.Normalize(vmin=param_array.min(), vmax=param_array.max())
    cmap = mpl.cm.ScalarMappable(norm=norm, cmap=mpl.cm.plasma)
    cmap.set_array([])

    for sim_index in range(param_array.shape[0]):
        ax.plot(x_array, y_array_all[sim_index], 
                 '-', alpha= 0.25, c=cmap.to_rgba(param_array[sim_index])
               )#, 
                 # label='Sim: '+str(sim_index) )

    # plt.plot(stellar_mass_test, gsmf_um_test, 'k.', label='UM z=0.00')
    # plt.axhline(y=0, linestyle='dashed', color='black')
    # plt.yscale('log')
    
    
    if mlim1 != None: ax.set_xlim(mlim1, mlim2)
    ax.set_xscale('log')

    # plt.ylim(-0.02, 0.02)

    # clb = f.colorbar(cmap , ax=a)
    # clb.ax.tick_params(labelsize=15) 
    # clb.ax.set_title(param_name_str, fontsize=15)

    # plt.title(title_str, fontsize=15)
    # a.set_xlabel(xlabel_str, fontsize=15)
    # a.set_ylabel(ylabel_str, fontsize=15)
    
    clb = f.colorbar(cmap , ax=ax)
    clb.ax.tick_params(labelsize=15) 
    clb.ax.set_title(param_name_str, fontsize=15)

    if title_str and ax is None:
        plt.title(title_str, fontsize=15)
    if xlabel_str:
        ax.set_xlabel(xlabel_str, fontsize=15)
    if ylabel_str:
        ax.set_ylabel(ylabel_str, fontsize=15)
    
    return f

# %% ../nbs/10_viz.ipynb 5
def plot_scatter_matrix(df:pd.DataFrame=None, 
                        colors:str=None,
                       ): 
    
    f, a = plt.subplots(1,1, figsize = (10, 10))
    scatter_matrix = pd.plotting.scatter_matrix(df, 
                                                color=colors,  
                                                figsize=(10,10), 
                                                alpha=1.0, 
                                                ax=a, 
                                                grid=False, 
                                                diagonal='hist',
                                                range_padding=0.1,
                                                s=80);

    for ax in scatter_matrix.ravel():
        ax.set_xlabel(ax.get_xlabel(), fontsize = 14, rotation = 0)
        ax.set_ylabel(ax.get_ylabel(), fontsize = 14, rotation = 90)
        ax.xaxis.set_major_formatter(FormatStrFormatter('%.2f'))
        ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
        
    return f

# %% ../nbs/10_viz.ipynb 6
def plot_train_diagnostics(sepia_model:SepiaModel=None, # Input data in SEPIA format, after PCA
                          ) -> tuple: #Pair-plot and Trace-plot
    samples_dict = sepia_model.get_samples()
    theta_pairs = SepiaPlot.theta_pairs(samples_dict)
    mcmc_trace = SepiaPlot.mcmc_trace(samples_dict)
    
    return theta_pairs, mcmc_trace

# %% ../nbs/10_viz.ipynb 7


def validation_plot(x_all, 
                    target_vals, 
                    pred_mean, 
                    pred_quant,
                    title_str,
                    xlabel_str,
                    ylabel_str,
                    mlim1,
                    mlim2,
                    x_scale,
                    y_scale,
                    ):

    f, a = plt.subplots(2, 1, figsize=(8, 6), gridspec_kw={'height_ratios': [2, 1]}, sharex=True)
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.05)

    colors = ['b', 'r', 'g', ]
    styles = ['-', '--']
    # styles_label = ['Flamingo-like', 'Emulated mean', 'Emulated (0.05, 0.95) quantile']
    styles_label = ['Simulation mean', 'Emulated mean']


    for one_index in range(pred_mean.shape[1]):

        a[0].plot(x_all, target_vals[one_index], c=colors[one_index], ls=styles[0])
        a[0].plot(x_all, pred_mean[:, one_index], c=colors[one_index], ls=styles[1])
        # a[0].plot(x_all, pred_quant[:, one_index, 0], c=colors[one_index], ls=styles[2])
        a[0].fill_between(x_all, pred_quant[:, one_index, 0], pred_quant[:, one_index, 1], color=colors[one_index], alpha=0.2)

        a[1].plot(x_all, (pred_mean[:, one_index]/target_vals[one_index]) - 1, c=colors[one_index])
        

    for cc, col in enumerate(colors):
        a[0].plot(np.NaN, np.NaN, c=colors[cc], label='Cosmology: ' + str(cc))

    ax2 = a[0].twinx()
    for ss, sty in enumerate(styles):
        ax2.plot(np.NaN, np.NaN, ls=styles[ss],
                 label=styles_label[ss], c='black')

    ax2.get_yaxis().set_visible(False)

    ylim1, ylim2 = a[0].get_ylim()
    print(ylim1, ylim2)
    # a[0].fill_between(x_all, 0.8*ylim1, 1.2*ylim2, where=(x_all < mlim1), color='k', alpha=0.5)
    # a[0].fill_between(x_all, 0.8*ylim1, 1.2*ylim2, where=(x_all > mlim2), color='k', alpha=0.5)

    # a[1].fill_between(x_all, -0.5, 0.5, where=(x_all < mlim1), color='k', alpha=0.5)
    # a[1].fill_between(x_all, -0.5, 0.5, where=(x_all > mlim2), color='k', alpha=0.5)
    
    # a[0].fill_between(x_all, xy_lims[0], xy_lims[1], where=(x_all > mlim1), color='k', alpha=0.15)
    # a[1].fill_between(x_all, delta_y_lims[0], delta_y_lims[1], where=(x_all > mlim1), color='k', alpha=0.15)


    a[0].legend(loc=1, title='Test configuration')
    ax2.legend(loc=7)
    a[1].set_xlabel(xlabel_str)
    a[0].set_ylabel(ylabel_str)
    a[1].set_ylabel(r'$\delta$')
    
    a[0].set_xscale(x_scale)
    a[0].set_yscale(y_scale)
    
    # plt.show()
    a[0].set_xlim(mlim1, mlim2)
    a[0].set_ylim(ylim1, ylim2)
    a[1].set_ylim(-0.5, 0.5)
    
    return f, a

def validation_plot(x_all, 
                    target_vals, 
                    pred_mean, 
                    pred_quant,
                    title_str,
                    xlabel_str,
                    ylabel_str,
                    mlim1,
                    mlim2,
                    x_scale,
                    y_scale,
                    ):

    f, a = plt.subplots(2, 1, figsize=(8, 6), gridspec_kw={'height_ratios': [2, 1]}, sharex=True)
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.05)

    colors = ['b', 'r', 'g', ]
    styles = ['-', '--']
    styles_label = ['Simulation mean', 'Emulated mean']

    log_transformed = (y_scale == 'log')
    max_rel_error_mean = 0.0
    max_rel_error_quant = 0.0

    for one_index in range(pred_mean.shape[1]):

        a[0].plot(x_all, target_vals[one_index], c=colors[one_index], ls=styles[0])
        a[0].plot(x_all, pred_mean[:, one_index], c=colors[one_index], ls=styles[1])
        a[0].fill_between(x_all, pred_quant[:, one_index, 0], pred_quant[:, one_index, 1], color=colors[one_index], alpha=0.2)

        if log_transformed:
            # data is log(y), so delta = log(pred) - log(target)
            delta = pred_mean[:, one_index] - target_vals[one_index]
            delta_quant_low = pred_quant[:, one_index, 0] - target_vals[one_index]
            delta_quant_high = pred_quant[:, one_index, 1] - target_vals[one_index]
        else:
            delta = (pred_mean[:, one_index] / target_vals[one_index]) - 1
            delta_quant_low = (pred_quant[:, one_index, 0] / target_vals[one_index]) - 1
            delta_quant_high = (pred_quant[:, one_index, 1] / target_vals[one_index]) - 1

        a[1].plot(x_all, delta, c=colors[one_index])
        
        max_rel_error_mean = max(max_rel_error_mean, np.max(np.abs(delta)))
        max_rel_error_quant = max(max_rel_error_quant, 
                                   np.max(np.abs(delta_quant_low)),
                                   np.max(np.abs(delta_quant_high)))

    if log_transformed:
        print(f"Maximum relative error (mean): {max_rel_error_mean:.4f} dex")
        print(f"Maximum relative error (quantiles): {max_rel_error_quant:.4f} dex")
    else:
        print(f"Maximum relative error (mean): {max_rel_error_mean:.4f} ({max_rel_error_mean*100:.2f}%)")
        print(f"Maximum relative error (quantiles): {max_rel_error_quant:.4f} ({max_rel_error_quant*100:.2f}%)")

    for cc, col in enumerate(colors):
        a[0].plot(np.NaN, np.NaN, c=colors[cc], label='Cosmology: ' + str(cc))

    ax2 = a[0].twinx()
    for ss, sty in enumerate(styles):
        ax2.plot(np.NaN, np.NaN, ls=styles[ss],
                 label=styles_label[ss], c='black')

    ax2.get_yaxis().set_visible(False)

    ylim1, ylim2 = a[0].get_ylim()
    print(ylim1, ylim2)

    a[0].legend(loc=1, title='Test configuration')
    ax2.legend(loc=7)
    a[1].set_xlabel(xlabel_str)
    a[0].set_ylabel(ylabel_str)
    a[1].set_ylabel(r'$\delta$')
    
    a[0].set_xscale(x_scale)
    a[0].set_yscale(y_scale)
    
    a[0].set_xlim(mlim1, mlim2)
    a[0].set_ylim(ylim1, ylim2)
    a[1].set_ylim(-0.5, 0.5)
    
    return f, a


def validation_plot(x_all, 
                    target_vals, 
                    pred_mean, 
                    pred_quant,
                    title_str,
                    xlabel_str,
                    ylabel_str,
                    mlim1,
                    mlim2,
                    x_scale,
                    y_scale,
                    ):

    f, a = plt.subplots(2, 1, figsize=(8, 6), gridspec_kw={'height_ratios': [2, 1]}, sharex=True)
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.05)

    colors = ['b', 'r', 'g', ]
    styles = ['-', '--']
    styles_label = ['Simulation mean', 'Emulated mean']

    # Detect if data is log-transformed by checking if values are small (log-space)
    # vs large (linear space). Log10 of typical astrophysical quantities are O(1) or smaller.
    max_target = np.max(np.abs(target_vals))
    log_transformed = (y_scale == 'log') and (max_target < 100)
    
    # Mask for valid x range
    if mlim1 is not None and mlim2 is not None:
        valid_x_mask = (x_all >= mlim1) & (x_all <= mlim2)
    else:
        valid_x_mask = np.ones(len(x_all), dtype=bool)
    
    max_rel_error_mean = 0.0
    max_rel_error_quant = 0.0

    for one_index in range(pred_mean.shape[1]):

        a[0].plot(x_all, target_vals[one_index], c=colors[one_index], ls=styles[0])
        a[0].plot(x_all, pred_mean[:, one_index], c=colors[one_index], ls=styles[1])
        a[0].fill_between(x_all, pred_quant[:, one_index, 0], pred_quant[:, one_index, 1], color=colors[one_index], alpha=0.2)

        if log_transformed:
            # data is log(y), so delta = log(pred) - log(target)
            delta = pred_mean[:, one_index] - target_vals[one_index]
            delta_quant_low = pred_quant[:, one_index, 0] - target_vals[one_index]
            delta_quant_high = pred_quant[:, one_index, 1] - target_vals[one_index]
            # convert to relative error: 10^delta - 1
            rel_error_mean = np.abs(10**delta - 1)
            rel_error_quant = np.maximum(np.abs(10**delta_quant_low - 1), np.abs(10**delta_quant_high - 1))
        else:
            # Mask out zeros to avoid division by zero
            valid_mask = target_vals[one_index] != 0
            
            delta = np.full_like(pred_mean[:, one_index], np.nan)
            delta_quant_low = np.full_like(pred_mean[:, one_index], np.nan)
            delta_quant_high = np.full_like(pred_mean[:, one_index], np.nan)
            
            delta[valid_mask] = (pred_mean[valid_mask, one_index] / target_vals[one_index][valid_mask]) - 1
            delta_quant_low[valid_mask] = (pred_quant[valid_mask, one_index, 0] / target_vals[one_index][valid_mask]) - 1
            delta_quant_high[valid_mask] = (pred_quant[valid_mask, one_index, 1] / target_vals[one_index][valid_mask]) - 1
            
            rel_error_mean = np.abs(delta)
            rel_error_quant = np.maximum(np.abs(delta_quant_low), np.abs(delta_quant_high))

        a[1].plot(x_all, delta, c=colors[one_index])
        
        # Only compute max error within valid x range
        max_rel_error_mean = max(max_rel_error_mean, np.nanmax(rel_error_mean[valid_x_mask]))
        max_rel_error_quant = max(max_rel_error_quant, np.nanmax(rel_error_quant[valid_x_mask]))

    print(f"Maximum relative error (mean): {max_rel_error_mean:.4f} ({max_rel_error_mean*100:.2f}%)")
    print(f"Maximum relative error (quantiles): {max_rel_error_quant:.4f} ({max_rel_error_quant*100:.2f}%)")

    for cc, col in enumerate(colors):
        a[0].plot(np.NaN, np.NaN, c=colors[cc], label='Cosmology: ' + str(cc))

    ax2 = a[0].twinx()
    for ss, sty in enumerate(styles):
        ax2.plot(np.NaN, np.NaN, ls=styles[ss],
                 label=styles_label[ss], c='black')

    ax2.get_yaxis().set_visible(False)

    ylim1, ylim2 = a[0].get_ylim()
    print(ylim1, ylim2)

    a[0].legend(loc=1, title='Test configuration')
    ax2.legend(loc=7)
    a[1].set_xlabel(xlabel_str)
    a[0].set_ylabel(ylabel_str)
    a[1].set_ylabel(r'$\delta$')
    
    a[0].set_xscale(x_scale)
    a[0].set_yscale(y_scale)
    
    a[0].set_xlim(mlim1, mlim2)
    a[0].set_ylim(ylim1, ylim2)
    a[1].set_ylim(-0.5, 0.5)
    
    return f, a


def validation_plot(x_all, 
                    target_vals, 
                    pred_mean, 
                    pred_quant,
                    title_str,
                    xlabel_str,
                    ylabel_str,
                    mlim1,
                    mlim2,
                    x_scale,
                    y_scale,
                    error_xlim=None,  # tuple (min, max) for error computation range, defaults to (mlim1, mlim2)
                    ):

    f, a = plt.subplots(2, 1, figsize=(8, 6), gridspec_kw={'height_ratios': [2, 1]}, sharex=True)
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.05)

    colors = ['b', 'r', 'g', ]
    styles = ['-', '--']
    styles_label = ['Simulation mean', 'Emulated mean']

    # Detect if data is log-transformed by checking if values are small (log-space)
    # vs large (linear space). Log10 of typical astrophysical quantities are O(1) or smaller.
    max_target = np.max(np.abs(target_vals))
    log_transformed = (y_scale == 'log') and (max_target < 100)
    
    # Mask for valid x range for error computation
    if error_xlim is not None:
        err_min, err_max = error_xlim
    else:
        err_min, err_max = mlim1, mlim2
    
    if err_min is not None and err_max is not None:
        valid_x_mask = (x_all >= err_min) & (x_all <= err_max)
    else:
        valid_x_mask = np.ones(len(x_all), dtype=bool)
    
    all_rel_errors_mean = []
    all_rel_errors_quant = []

    for one_index in range(pred_mean.shape[1]):

        a[0].plot(x_all, target_vals[one_index], c=colors[one_index], ls=styles[0])
        a[0].plot(x_all, pred_mean[:, one_index], c=colors[one_index], ls=styles[1])
        a[0].fill_between(x_all, pred_quant[:, one_index, 0], pred_quant[:, one_index, 1], color=colors[one_index], alpha=0.2)

        if log_transformed:
            # data is log(y), so delta = log(pred) - log(target)
            delta = pred_mean[:, one_index] - target_vals[one_index]
            delta_quant_low = pred_quant[:, one_index, 0] - target_vals[one_index]
            delta_quant_high = pred_quant[:, one_index, 1] - target_vals[one_index]
            # convert to relative error: 10^delta - 1
            rel_error_mean = np.abs(10**delta - 1)
            rel_error_quant = np.maximum(np.abs(10**delta_quant_low - 1), np.abs(10**delta_quant_high - 1))
        else:
            # Mask out zeros to avoid division by zero
            valid_mask = target_vals[one_index] != 0
            
            delta = np.full_like(pred_mean[:, one_index], np.nan)
            delta_quant_low = np.full_like(pred_mean[:, one_index], np.nan)
            delta_quant_high = np.full_like(pred_mean[:, one_index], np.nan)
            
            delta[valid_mask] = (pred_mean[valid_mask, one_index] / target_vals[one_index][valid_mask]) - 1
            delta_quant_low[valid_mask] = (pred_quant[valid_mask, one_index, 0] / target_vals[one_index][valid_mask]) - 1
            delta_quant_high[valid_mask] = (pred_quant[valid_mask, one_index, 1] / target_vals[one_index][valid_mask]) - 1
            
            rel_error_mean = np.abs(delta)
            rel_error_quant = np.maximum(np.abs(delta_quant_low), np.abs(delta_quant_high))

        a[1].plot(x_all, delta, c=colors[one_index])
        
        # Collect errors within valid x range
        all_rel_errors_mean.append(rel_error_mean[valid_x_mask])
        all_rel_errors_quant.append(rel_error_quant[valid_x_mask])

    # Combine all errors across cosmologies
    all_rel_errors_mean = np.concatenate(all_rel_errors_mean)
    all_rel_errors_quant = np.concatenate(all_rel_errors_quant)
    
    max_rel_error_mean = np.nanmax(all_rel_errors_mean)
    max_rel_error_quant = np.nanmax(all_rel_errors_quant)
    mean_rel_error_mean = np.nanmean(all_rel_errors_mean)
    mean_rel_error_quant = np.nanmean(all_rel_errors_quant)

    print(f"Maximum relative error (mean): {max_rel_error_mean:.4f} ({max_rel_error_mean*100:.2f}%)")
    print(f"Mean relative error (mean): {mean_rel_error_mean:.4f} ({mean_rel_error_mean*100:.2f}%)")
    print(f"Maximum relative error (quantiles): {max_rel_error_quant:.4f} ({max_rel_error_quant*100:.2f}%)")
    print(f"Mean relative error (quantiles): {mean_rel_error_quant:.4f} ({mean_rel_error_quant*100:.2f}%)")

    for cc, col in enumerate(colors):
        a[0].plot(np.NaN, np.NaN, c=colors[cc], label='Cosmology: ' + str(cc))

    ax2 = a[0].twinx()
    for ss, sty in enumerate(styles):
        ax2.plot(np.NaN, np.NaN, ls=styles[ss],
                 label=styles_label[ss], c='black')

    ax2.get_yaxis().set_visible(False)

    ylim1, ylim2 = a[0].get_ylim()
    print(ylim1, ylim2)

    a[0].legend(loc=1, title='Test configuration')
    ax2.legend(loc=7)
    a[1].set_xlabel(xlabel_str)
    a[0].set_ylabel(ylabel_str)
    a[1].set_ylabel(r'$\delta$')
    
    a[0].set_xscale(x_scale)
    a[0].set_yscale(y_scale)
    
    a[0].set_xlim(mlim1, mlim2)
    a[0].set_ylim(ylim1, ylim2)
    a[1].set_ylim(-0.5, 0.5)
    
    return f, a

def validation_plot_kall(k_all:np.array=None, 
                    target_vals:np.array=None, 
                    pred_mean:np.array=None, 
                    pred_quant:np.array=None, 
                    xy_lims:np.array=[2e-2, 1e1, 0.98, 1.3]
                    ):
    
    delta_y_lims = [-0.021, 0.021]

    f, a = plt.subplots(2, 1, figsize=(8, 6), gridspec_kw={'height_ratios': [2, 1]}, sharex=True)
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=0.05)

    colors = ['b', 'r', 'g', ]
    styles = ['-', '--']
    styles_label = ['Hi-COLA', 'Emulated mean']


    for one_index in range(pred_mean.shape[1]):

        a[0].plot(k_all, target_vals[one_index], c=colors[one_index], ls=styles[0])
        a[0].plot(k_all, pred_mean[:, one_index], c=colors[one_index], ls=styles[1])
        # a[0].plot(k_all, pred_quant[:, one_index, 0], c=colors[one_index], ls=styles[2])

        a[0].fill_between(k_all, pred_quant[:, one_index, 0], pred_quant[:, one_index, 1], color=colors[one_index], alpha=0.2) 
        #'Emulated (0.05, 0.95) quantile'


        a[1].plot(k_all, (pred_mean[:, one_index]/target_vals[one_index]) - 1, c=colors[one_index])

    for cc, col in enumerate(colors):
        a[0].plot(np.NaN, np.NaN, c=colors[cc], label='Cosmology: ' + str(cc))

    ax2 = a[0].twinx()
    for ss, sty in enumerate(styles):
        ax2.plot(np.NaN, np.NaN, ls=styles[ss],
                 label=styles_label[ss], c='black')

    ax2.get_yaxis().set_visible(False)
    
    a[0].fill_between(k_all, xy_lims[0], xy_lims[1], where=(k_all > 1.2), color='k', alpha=0.15)
    a[1].fill_between(k_all, delta_y_lims[0], delta_y_lims[1], where=(k_all > 1.2), color='k', alpha=0.15)


    a[0].legend(loc=1, title='Test configuration')
    ax2.legend(loc=3)
    a[1].set_xlabel('k[h/Mpc]')
    a[1].set_ylabel(r'$\delta B(k)/B(k)$')
    a[0].set_ylabel('B(k)')
    a[0].set_xscale('log')
    # plt.show()
    a[0].set_xlim(xy_lims[0], xy_lims[1])
    a[0].set_ylim(xy_lims[2], xy_lims[3])
    a[1].set_ylim(delta_y_lims[0], delta_y_lims[1])
    
    return f, a

'''
def sensitivity_plot(k_all, # all wavenumbers
                     params_all, # all parameters
                     sepia_model, # SEPIA emulator model
                     emulator_function, # function which takes in sepia model and parameters
                     param_name, # Parameter name,
                     title_str,
                     xlabel_str,
                     ylabel_str,
                     mlim1,
                     mlim2,
                     x_scale,
                     y_scale):

    color_by_index = 0
    colorparams = params_all[:, color_by_index]
    # colorparams = X_test_transformed1[:, color_by_index]
    colormap = cm.Dark2
    normalize = mcolors.Normalize(vmin=np.min(colorparams), vmax=np.max(colorparams))

    allMax = np.max(params_all, axis = 0)
    allMin = np.min(params_all, axis = 0)
    allMean = np.mean(params_all, axis = 0)

    numPlots = 300

    fig, ax = plt.subplots(params_all.shape[1], 1, figsize = (7, 15), sharex='col')
    plt.subplots_adjust(wspace=0.25)
    plt.subplots_adjust(hspace=0.05)
    plt.suptitle(title_str, fontsize=18, y=0.9)


    for paramNo in range(params_all.shape[1]):
            para_range = np.linspace(allMin[paramNo], allMax[paramNo], numPlots)        
            # colorList = plt.cm.coolwarm(np.linspace(0,1,numPlots))

            colormap = cm.coolwarm
            normalize = mcolors.Normalize(vmin=np.min(allMin[paramNo]), vmax=allMax[paramNo])

            for plotID in range(numPlots):
                    para_plot = np.copy(allMean)
                    para_plot[paramNo] = para_range[plotID]  #### allMean gets changed everytime!!

                    color = colormap(normalize(para_plot[paramNo]))

                    gsmf_decoded, _ = emulator_function(sepia_model, para_plot)

                    lineObj = ax[paramNo].plot(k_all, gsmf_decoded, lw= 1, color = color, alpha=0.7) 

                    ax[paramNo].set_yscale(y_scale)
                    ax[paramNo].set_xscale(x_scale)
                    ax[paramNo].set_ylabel(ylabel_str, fontsize=18)
                    ax[paramNo].set_yticks([], minor = True)
                    
                    # ax[paramNo].set_xlim(mlim1, mlim2)
                    # ax[paramNo].set_ylim(ylim1, ylim2)
                            
            
            # Colorbar setup
            s_map = cm.ScalarMappable(norm=normalize, cmap=colormap)
            s_map.set_array(colorparams)

            # If color parameters is a linspace, we can set boundaries in this way
            halfdist = (colorparams[1] - colorparams[0])/2.0
            boundaries = np.linspace(colorparams[0] - halfdist, colorparams[-1] + halfdist, len(colorparams) + 1)

            cbar = fig.colorbar(s_map, spacing='proportional', ax=ax[paramNo])

            cbarlabel = param_name[paramNo]
            cbar.set_label(cbarlabel, fontsize=20)
            
            ylim1, ylim2 = ax[paramNo].get_ylim()
            if mlim1 !=None: ax[paramNo].fill_between(k_all, 0.8*ylim1, 1.2*ylim2, where=(k_all < mlim1), color='k', alpha=0.1)
            if mlim1 !=None: ax[paramNo].fill_between(k_all, 0.8*ylim1, 1.2*ylim2, where=(k_all > mlim2), color='k', alpha=0.1)

            ax[paramNo].set_ylim(ylim1, ylim2)
    ax[paramNo].set_xlabel(xlabel_str, fontsize=18)
    # plt.show()

    
    return fig


'''

def sensitivity_plot(k_all, # all wavenumbers
                     params_all, # all parameters
                     sepia_model, # SEPIA emulator model
                     emulator_function, # function which takes in sepia model and parameters
                     param_name, # Parameter name,
                     title_str,
                     xlabel_str,
                     ylabel_str,
                     mlim1,
                     mlim2,
                     x_scale,
                     y_scale):

    color_by_index = 0
    colorparams = params_all[:, color_by_index]
    colormap = cm.Dark2
    normalize = mcolors.Normalize(vmin=np.min(colorparams), vmax=np.max(colorparams))

    allMax = np.max(params_all, axis=0)
    allMin = np.min(params_all, axis=0)
    allMean = np.mean(params_all, axis=0)

    numPlots = 500

    fig, ax = plt.subplots(params_all.shape[1], 1, figsize=(7, 27), sharex='col')
    plt.subplots_adjust(wspace=0.25, hspace=0.05)
    plt.suptitle(title_str, fontsize=18, y=0.9)

    # Step 1: Determine the global y limits across all subplots
    global_ylim1 = np.inf
    global_ylim2 = -np.inf

    for paramNo in range(params_all.shape[1]):
        para_range = np.linspace(allMin[paramNo], allMax[paramNo], numPlots)        

        colormap = cm.coolwarm
        normalize = mcolors.Normalize(vmin=allMin[paramNo], vmax=allMax[paramNo])

        for plotID in range(numPlots):
            para_plot = np.copy(allMean)
            para_plot[paramNo] = para_range[plotID] 

            color = colormap(normalize(para_plot[paramNo]))

            gsmf_decoded, _ = emulator_function(sepia_model, para_plot)

            ax[paramNo].plot(k_all, gsmf_decoded, lw=1, color=color, alpha=0.7)

            ax[paramNo].set_yscale(y_scale)
            ax[paramNo].set_xscale(x_scale)
            ax[paramNo].set_ylabel(ylabel_str, fontsize=18)
            ax[paramNo].set_yticks([], minor=True)

            # Update global ylim
            global_ylim1 = min(global_ylim1, np.min(gsmf_decoded))
            global_ylim2 = max(global_ylim2, np.max(gsmf_decoded))

        # Colorbar setup
        s_map = cm.ScalarMappable(norm=normalize, cmap=colormap)
        s_map.set_array(colorparams)

        cbar = fig.colorbar(s_map, spacing='proportional', ax=ax[paramNo])
        cbar.set_label(param_name[paramNo], fontsize=15)

    # Step 2: Apply the same y limits to all subplots
    for paramNo in range(params_all.shape[1]):
        ax[paramNo].set_ylim(global_ylim1, global_ylim2)

        if mlim1 is not None:
            ax[paramNo].fill_between(k_all, 0.8 * global_ylim1, 1.2 * global_ylim2, where=(k_all < mlim1), color='k', alpha=0.1)
            ax[paramNo].fill_between(k_all, 0.8 * global_ylim1, 1.2 * global_ylim2, where=(k_all > mlim2), color='k', alpha=0.1)

    ax[-1].set_xlabel(xlabel_str, fontsize=15)

    return fig

def sensitivity_plot_gsmf(k_all, # all wavenumbers
                     params_all, # all parameters
                     sepia_model, # SEPIA emulator model
                     emulator_function, # function which takes in sepia model and parameters
                     param_name, # Parameter name,
                     title_str,
                     xlabel_str,
                     ylabel_str,
                     mlim1,
                     mlim2,
                     x_scale,
                     y_scale):

    color_by_index = 0
    colorparams = params_all[:, color_by_index]
    # colorparams = X_test_transformed1[:, color_by_index]
    colormap = cm.Dark2
    normalize = mcolors.Normalize(vmin=np.min(colorparams), vmax=np.max(colorparams))

    allMax = np.max(params_all, axis = 0)
    allMin = np.min(params_all, axis = 0)
    allMean = np.mean(params_all, axis = 0)

    numPlots = 300

    fig, ax = plt.subplots(params_all.shape[1], 1, figsize = (7, 27), sharex='col')
    plt.subplots_adjust(wspace=0.25)
    plt.subplots_adjust(hspace=0.05)
    plt.suptitle(title_str, fontsize=18, y=0.9)


    for paramNo in range(params_all.shape[1]):
            para_range = np.linspace(allMin[paramNo], allMax[paramNo], numPlots)        
            # colorList = plt.cm.coolwarm(np.linspace(0,1,numPlots))

            colormap = cm.coolwarm
            normalize = mcolors.Normalize(vmin=np.min(allMin[paramNo]), vmax=allMax[paramNo])

            for plotID in range(numPlots):
                    para_plot = np.copy(allMean)
                    para_plot[paramNo] = para_range[plotID]  #### allMean gets changed everytime!!

                    color = colormap(normalize(para_plot[paramNo]))

                    gsmf_decoded, _ = emulator_function(sepia_model, para_plot)
                    gsmf_decoded = np.log10(gsmf_decoded)

                    lineObj = ax[paramNo].plot(k_all, gsmf_decoded, lw= 1, color = color, alpha=0.7) 

                    ax[paramNo].set_yscale(y_scale)
                    ax[paramNo].set_xscale(x_scale)
                    ax[paramNo].set_ylabel(ylabel_str, fontsize=15)
                    # ax[paramNo].set_yticks([], minor = True)
                    
                    # ax[paramNo].set_xlim(mlim1, mlim2)
                    # ax[paramNo].set_ylim(ylim1, ylim2)
                            
            
            # Colorbar setup
            s_map = cm.ScalarMappable(norm=normalize, cmap=colormap)
            s_map.set_array(colorparams)

            # If color parameters is a linspace, we can set boundaries in this way
            halfdist = (colorparams[1] - colorparams[0])/2.0
            boundaries = np.linspace(colorparams[0] - halfdist, colorparams[-1] + halfdist, len(colorparams) + 1)

            cbar = fig.colorbar(s_map, spacing='proportional', ax=ax[paramNo])

            cbarlabel = param_name[paramNo]
            cbar.set_label(cbarlabel, fontsize=20)
            
            ylim1, ylim2 = ax[paramNo].get_ylim()
            ax[paramNo].fill_between(k_all, 0.8*ylim1, 1.2*ylim2, where=(k_all < mlim1), color='k', alpha=0.1)
            ax[paramNo].fill_between(k_all, 0.8*ylim1, 1.2*ylim2, where=(k_all > mlim2), color='k', alpha=0.1)

            
            ylim1 = 9e-5
            ylim2 = 1e-1
            ax[paramNo].set_ylim(ylim1, ylim2)
    ax[paramNo].set_xlabel(xlabel_str, fontsize=15)
    # plt.show()

    
    return fig




def plot_mcmc(samples, params_list, if_truth_known=False):
    param_names = [param[0] for param in params_list]
    param_ranges = [(param[2], param[3]) for param in params_list]
    truths = [param[1] for param in params_list] if if_truth_known else None

    fig = pygtc.plotGTC(samples, 
                        paramNames=param_names,
                        truths=truths if if_truth_known else None,
                        figureSize=10, 
                        plotDensity=True, 
                        filledPlots=True, 
                        smoothingKernel=3, 
                        nContourLevels=3,  
                        customLabelFont={'family': 'DejaVu Sans', 'size': 12}, 
                        customTickFont={'family': 'DejaVu Sans', 'size': 12},
                        paramRanges=None)

                        # paramRanges=param_ranges if if_truth_known else None)

    return fig


def plot_mcmc_combined(samples1, samples2, params_list, if_truth_known=False):
    param_names = [param[0] for param in params_list]
    param_ranges = [(param[2], param[3]) for param in params_list]
    truths = [param[1] for param in params_list] if if_truth_known else None

    fig = pygtc.plotGTC([samples1, samples2], 
                        paramNames=param_names,
                        truths=truths if if_truth_known else None,
                        figureSize=10, 
                        plotDensity=False, 
                        filledPlots=True, 
                        smoothingKernel=3, 
                        nContourLevels=3,  
                        customLabelFont={'family': 'DejaVu Sans', 'size': 12}, 
                        customTickFont={'family': 'DejaVu Sans', 'size': 12},
                        paramRanges=None)

                        # paramRanges=param_ranges if if_truth_known else None)

    return fig

def plot_mcmc(samples, params_list, if_truth_known=False):
    param_names = [param[0] for param in params_list]
    param_ranges = [(param[2], param[3]) for param in params_list]
    truths = [param[1] for param in params_list] if if_truth_known else None

    fig = pygtc.plotGTC(samples, 
                        paramNames=param_names,
                        truths=truths if if_truth_known else None,
                        figureSize=10, 
                        plotDensity=True, 
                        filledPlots=True, 
                        smoothingKernel=2.5, 
                        nContourLevels=3,  
                        customLabelFont={'family': 'DejaVu Sans', 'size': 12}, 
                        customTickFont={'family': 'DejaVu Sans', 'size': 12},
                        paramRanges=None)

                        # paramRanges=param_ranges if if_truth_known else None)

    return fig


def plot_convergence(sampler, params_list, nrun, ndim, nwalkers):
    n_params = len(params_list)  # Number of parameters
    fig, ax = plt.subplots(n_params, 1, figsize=(20, 2 * n_params), sharex=True)
    ax[-1].set_xlabel('steps')

    for i, param in enumerate(params_list):
        ax[i].plot(np.arange(nrun), sampler.chain[:, :, i].T, lw=0.2, alpha=0.9)
        ax[i].text(0.9, 0.9, param[0], horizontalalignment='center', verticalalignment='center', transform=ax[i].transAxes, fontsize=12)

    # fig.savefig('plots/convergence_mcmc_ndim{}_nwalk{}_run{}_{}-{}.png'.format(ndim, nwalkers, nrun, summary_stat, design), dpi=100)

    return fig